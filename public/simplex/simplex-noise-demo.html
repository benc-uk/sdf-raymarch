<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simplex Noise Visualizations</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            padding: 20px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        h1 {
            text-align: center;
            margin-bottom: 30px;
            color: #4a9eff;
        }
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        .canvas-wrapper {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }
        .canvas-wrapper h2 {
            margin-bottom: 10px;
            font-size: 1.2em;
            color: #4a9eff;
        }
        .canvas-wrapper p {
            margin-bottom: 10px;
            font-size: 0.9em;
            color: #b0b0b0;
        }
        canvas {
            display: block;
            width: 100%;
            height: auto;
            border: 2px solid #3a3a3a;
            border-radius: 4px;
        }
        .controls {
            margin-top: 10px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        label {
            font-size: 0.85em;
            color: #b0b0b0;
        }
        input[type="range"] {
            width: 150px;
        }
        input[type="number"] {
            width: 80px;
            padding: 4px;
            background: #3a3a3a;
            border: 1px solid #4a4a4a;
            color: #e0e0e0;
            border-radius: 3px;
        }
        .value-display {
            font-weight: bold;
            color: #4a9eff;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Simplex Noise Visualizations</h1>
        
        <div class="grid">
            <div class="canvas-wrapper">
                <h2>2D Simplex Noise</h2>
                <p>Classic 2D noise pattern</p>
                <canvas id="canvas2d" width="512" height="512"></canvas>
                <div class="controls">
                    <div class="control-group">
                        <label>Scale: <span class="value-display" id="scale2d-val">100</span></label>
                        <input type="range" id="scale2d" min="10" max="500" value="100">
                    </div>
                </div>
            </div>

            <div class="canvas-wrapper">
                <h2>2D Simplex Noise (Animated)</h2>
                <p>Noise moving through time</p>
                <canvas id="canvas2d-anim" width="512" height="512"></canvas>
                <div class="controls">
                    <div class="control-group">
                        <label>Scale: <span class="value-display" id="scale2d-anim-val">80</span></label>
                        <input type="range" id="scale2d-anim" min="10" max="300" value="80">
                    </div>
                    <div class="control-group">
                        <label>Speed: <span class="value-display" id="speed2d-val">1.0</span></label>
                        <input type="range" id="speed2d" min="0.1" max="5" step="0.1" value="1.0">
                    </div>
                </div>
            </div>

            <div class="canvas-wrapper">
                <h2>3D Simplex Noise (Z-slice)</h2>
                <p>Slice through 3D noise volume</p>
                <canvas id="canvas3d" width="512" height="512"></canvas>
                <div class="controls">
                    <div class="control-group">
                        <label>Z-Position: <span class="value-display" id="zpos-val">0.0</span></label>
                        <input type="range" id="zpos" min="-50" max="50" step="0.1" value="0">
                    </div>
                    <div class="control-group">
                        <label>Scale: <span class="value-display" id="scale3d-val">100</span></label>
                        <input type="range" id="scale3d" min="10" max="500" value="100">
                    </div>
                </div>
            </div>

            <div class="canvas-wrapper">
                <h2>3D Simplex Noise (Animated)</h2>
                <p>Moving through 3D noise volume</p>
                <canvas id="canvas3d-anim" width="512" height="512"></canvas>
                <div class="controls">
                    <div class="control-group">
                        <label>Scale: <span class="value-display" id="scale3d-anim-val">80</span></label>
                        <input type="range" id="scale3d-anim" min="10" max="300" value="80">
                    </div>
                    <div class="control-group">
                        <label>Speed: <span class="value-display" id="speed3d-val">1.0</span></label>
                        <input type="range" id="speed3d" min="0.1" max="5" step="0.1" value="1.0">
                    </div>
                </div>
            </div>

            <div class="canvas-wrapper">
                <h2>Fractal Brownian Motion (FBM)</h2>
                <p>Layered octaves of 2D noise</p>
                <canvas id="canvas-fbm" width="512" height="512"></canvas>
                <div class="controls">
                    <div class="control-group">
                        <label>Octaves: <span class="value-display" id="octaves-val">4</span></label>
                        <input type="range" id="octaves" min="1" max="8" value="4">
                    </div>
                    <div class="control-group">
                        <label>Scale: <span class="value-display" id="scale-fbm-val">100</span></label>
                        <input type="range" id="scale-fbm" min="20" max="300" value="100">
                    </div>
                </div>
            </div>

            <div class="canvas-wrapper">
                <h2>Turbulence</h2>
                <p>Absolute value of FBM for marble-like patterns</p>
                <canvas id="canvas-turbulence" width="512" height="512"></canvas>
                <div class="controls">
                    <div class="control-group">
                        <label>Octaves: <span class="value-display" id="turb-octaves-val">5</span></label>
                        <input type="range" id="turb-octaves" min="1" max="8" value="5">
                    </div>
                    <div class="control-group">
                        <label>Scale: <span class="value-display" id="scale-turb-val">80</span></label>
                        <input type="range" id="scale-turb" min="20" max="300" value="80">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Simplex Noise Implementation
        // Based on Stefan Gustavson's implementation
        class SimplexNoise {
            constructor() {
                // Permutation table
                this.p = [];
                for (let i = 0; i < 256; i++) {
                    this.p[i] = Math.floor(Math.random() * 256);
                }
                // Double permutation to avoid overflow
                this.perm = [];
                this.permMod12 = [];
                for (let i = 0; i < 512; i++) {
                    this.perm[i] = this.p[i & 255];
                    this.permMod12[i] = this.perm[i] % 12;
                }

                // Gradients for 2D
                this.grad3 = [
                    [1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0],
                    [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1],
                    [0, 1, 1], [0, -1, 1], [0, 1, -1], [0, -1, -1]
                ];

                // Skewing and unskewing factors
                this.F2 = 0.5 * (Math.sqrt(3.0) - 1.0);
                this.G2 = (3.0 - Math.sqrt(3.0)) / 6.0;
                this.F3 = 1.0 / 3.0;
                this.G3 = 1.0 / 6.0;
            }

            // 2D simplex noise
            noise2D(xin, yin) {
                let n0, n1, n2; // Noise contributions from the three corners

                // Skew the input space to determine which simplex cell we're in
                const s = (xin + yin) * this.F2;
                const i = Math.floor(xin + s);
                const j = Math.floor(yin + s);
                const t = (i + j) * this.G2;
                const X0 = i - t; // Unskew the cell origin back to (x,y) space
                const Y0 = j - t;
                const x0 = xin - X0; // The x,y distances from the cell origin
                const y0 = yin - Y0;

                // For the 2D case, the simplex shape is an equilateral triangle.
                // Determine which simplex we are in.
                let i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
                if (x0 > y0) {
                    i1 = 1; j1 = 0; // lower triangle, XY order: (0,0)->(1,0)->(1,1)
                } else {
                    i1 = 0; j1 = 1; // upper triangle, YX order: (0,0)->(0,1)->(1,1)
                }

                // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
                // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
                // c = (3-sqrt(3))/6
                const x1 = x0 - i1 + this.G2; // Offsets for middle corner in (x,y) unskewed coords
                const y1 = y0 - j1 + this.G2;
                const x2 = x0 - 1.0 + 2.0 * this.G2; // Offsets for last corner in (x,y) unskewed coords
                const y2 = y0 - 1.0 + 2.0 * this.G2;

                // Work out the hashed gradient indices of the three simplex corners
                const ii = i & 255;
                const jj = j & 255;
                const gi0 = this.permMod12[ii + this.perm[jj]];
                const gi1 = this.permMod12[ii + i1 + this.perm[jj + j1]];
                const gi2 = this.permMod12[ii + 1 + this.perm[jj + 1]];

                // Calculate the contribution from the three corners
                let t0 = 0.5 - x0 * x0 - y0 * y0;
                if (t0 < 0) {
                    n0 = 0.0;
                } else {
                    t0 *= t0;
                    n0 = t0 * t0 * this.dot2(this.grad3[gi0], x0, y0);
                }

                let t1 = 0.5 - x1 * x1 - y1 * y1;
                if (t1 < 0) {
                    n1 = 0.0;
                } else {
                    t1 *= t1;
                    n1 = t1 * t1 * this.dot2(this.grad3[gi1], x1, y1);
                }

                let t2 = 0.5 - x2 * x2 - y2 * y2;
                if (t2 < 0) {
                    n2 = 0.0;
                } else {
                    t2 *= t2;
                    n2 = t2 * t2 * this.dot2(this.grad3[gi2], x2, y2);
                }

                // Add contributions from each corner to get the final noise value.
                // The result is scaled to return values in the interval [-1,1].
                return 70.0 * (n0 + n1 + n2);
            }

            // 3D simplex noise
            noise3D(xin, yin, zin) {
                let n0, n1, n2, n3; // Noise contributions from the four corners

                // Skew the input space to determine which simplex cell we're in
                const s = (xin + yin + zin) * this.F3;
                const i = Math.floor(xin + s);
                const j = Math.floor(yin + s);
                const k = Math.floor(zin + s);
                const t = (i + j + k) * this.G3;
                const X0 = i - t;
                const Y0 = j - t;
                const Z0 = k - t;
                const x0 = xin - X0;
                const y0 = yin - Y0;
                const z0 = zin - Z0;

                // For the 3D case, the simplex shape is a slightly irregular tetrahedron.
                // Determine which simplex we are in.
                let i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords
                let i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords
                if (x0 >= y0) {
                    if (y0 >= z0) {
                        i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 1; k2 = 0;
                    } else if (x0 >= z0) {
                        i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 0; k2 = 1;
                    } else {
                        i1 = 0; j1 = 0; k1 = 1; i2 = 1; j2 = 0; k2 = 1;
                    }
                } else {
                    if (y0 < z0) {
                        i1 = 0; j1 = 0; k1 = 1; i2 = 0; j2 = 1; k2 = 1;
                    } else if (x0 < z0) {
                        i1 = 0; j1 = 1; k1 = 0; i2 = 0; j2 = 1; k2 = 1;
                    } else {
                        i1 = 0; j1 = 1; k1 = 0; i2 = 1; j2 = 1; k2 = 0;
                    }
                }

                // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),
                // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and
                // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where
                // c = 1/6.
                const x1 = x0 - i1 + this.G3;
                const y1 = y0 - j1 + this.G3;
                const z1 = z0 - k1 + this.G3;
                const x2 = x0 - i2 + 2.0 * this.G3;
                const y2 = y0 - j2 + 2.0 * this.G3;
                const z2 = z0 - k2 + 2.0 * this.G3;
                const x3 = x0 - 1.0 + 3.0 * this.G3;
                const y3 = y0 - 1.0 + 3.0 * this.G3;
                const z3 = z0 - 1.0 + 3.0 * this.G3;

                // Work out the hashed gradient indices of the four simplex corners
                const ii = i & 255;
                const jj = j & 255;
                const kk = k & 255;
                const gi0 = this.permMod12[ii + this.perm[jj + this.perm[kk]]];
                const gi1 = this.permMod12[ii + i1 + this.perm[jj + j1 + this.perm[kk + k1]]];
                const gi2 = this.permMod12[ii + i2 + this.perm[jj + j2 + this.perm[kk + k2]]];
                const gi3 = this.permMod12[ii + 1 + this.perm[jj + 1 + this.perm[kk + 1]]];

                // Calculate the contribution from the four corners
                let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
                if (t0 < 0) {
                    n0 = 0.0;
                } else {
                    t0 *= t0;
                    n0 = t0 * t0 * this.dot3(this.grad3[gi0], x0, y0, z0);
                }

                let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
                if (t1 < 0) {
                    n1 = 0.0;
                } else {
                    t1 *= t1;
                    n1 = t1 * t1 * this.dot3(this.grad3[gi1], x1, y1, z1);
                }

                let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
                if (t2 < 0) {
                    n2 = 0.0;
                } else {
                    t2 *= t2;
                    n2 = t2 * t2 * this.dot3(this.grad3[gi2], x2, y2, z2);
                }

                let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
                if (t3 < 0) {
                    n3 = 0.0;
                } else {
                    t3 *= t3;
                    n3 = t3 * t3 * this.dot3(this.grad3[gi3], x3, y3, z3);
                }

                // Add contributions from each corner to get the final noise value.
                // The result is scaled to stay just inside [-1,1]
                return 32.0 * (n0 + n1 + n2 + n3);
            }

            dot2(g, x, y) {
                return g[0] * x + g[1] * y;
            }

            dot3(g, x, y, z) {
                return g[0] * x + g[1] * y + g[2] * z;
            }

            // Fractal Brownian Motion (FBM)
            fbm2D(x, y, octaves = 4, persistence = 0.5, lacunarity = 2.0) {
                let total = 0;
                let frequency = 1;
                let amplitude = 1;
                let maxValue = 0;

                for (let i = 0; i < octaves; i++) {
                    total += this.noise2D(x * frequency, y * frequency) * amplitude;
                    maxValue += amplitude;
                    amplitude *= persistence;
                    frequency *= lacunarity;
                }

                return total / maxValue;
            }

            // Turbulence (absolute value of FBM)
            turbulence2D(x, y, octaves = 4, persistence = 0.5, lacunarity = 2.0) {
                let total = 0;
                let frequency = 1;
                let amplitude = 1;
                let maxValue = 0;

                for (let i = 0; i < octaves; i++) {
                    total += Math.abs(this.noise2D(x * frequency, y * frequency)) * amplitude;
                    maxValue += amplitude;
                    amplitude *= persistence;
                    frequency *= lacunarity;
                }

                return total / maxValue;
            }
        }

        // Create simplex noise instance
        const simplex = new SimplexNoise();

        // Canvas setup and rendering functions
        function render2D(canvas, scale) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const data = imageData.data;

            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const nx = x / scale;
                    const ny = y / scale;
                    const noise = simplex.noise2D(nx, ny);
                    const value = Math.floor(((noise + 1) / 2) * 255);
                    
                    const idx = (y * canvas.width + x) * 4;
                    data[idx] = value;
                    data[idx + 1] = value;
                    data[idx + 2] = value;
                    data[idx + 3] = 255;
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function render2DAnimated(canvas, scale, time) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const data = imageData.data;

            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const nx = x / scale + time;
                    const ny = y / scale;
                    const noise = simplex.noise2D(nx, ny);
                    const value = Math.floor(((noise + 1) / 2) * 255);
                    
                    const idx = (y * canvas.width + x) * 4;
                    data[idx] = value;
                    data[idx + 1] = value;
                    data[idx + 2] = value;
                    data[idx + 3] = 255;
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function render3D(canvas, scale, zpos) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const data = imageData.data;

            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const nx = x / scale;
                    const ny = y / scale;
                    const nz = zpos / scale;
                    const noise = simplex.noise3D(nx, ny, nz);
                    const value = Math.floor(((noise + 1) / 2) * 255);
                    
                    const idx = (y * canvas.width + x) * 4;
                    data[idx] = value;
                    data[idx + 1] = value;
                    data[idx + 2] = value;
                    data[idx + 3] = 255;
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function render3DAnimated(canvas, scale, time) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const data = imageData.data;

            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const nx = x / scale;
                    const ny = y / scale;
                    const nz = time;
                    const noise = simplex.noise3D(nx, ny, nz);
                    const value = Math.floor(((noise + 1) / 2) * 255);
                    
                    const idx = (y * canvas.width + x) * 4;
                    data[idx] = value;
                    data[idx + 1] = value;
                    data[idx + 2] = value;
                    data[idx + 3] = 255;
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function renderFBM(canvas, scale, octaves) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const data = imageData.data;

            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const nx = x / scale;
                    const ny = y / scale;
                    const noise = simplex.fbm2D(nx, ny, octaves);
                    const value = Math.floor(((noise + 1) / 2) * 255);
                    
                    const idx = (y * canvas.width + x) * 4;
                    data[idx] = value;
                    data[idx + 1] = value;
                    data[idx + 2] = value;
                    data[idx + 3] = 255;
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function renderTurbulence(canvas, scale, octaves) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const data = imageData.data;

            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const nx = x / scale;
                    const ny = y / scale;
                    const noise = simplex.turbulence2D(nx, ny, octaves);
                    const value = Math.floor(noise * 255);
                    
                    const idx = (y * canvas.width + x) * 4;
                    // Color gradient for turbulence
                    data[idx] = value;
                    data[idx + 1] = value * 0.8;
                    data[idx + 2] = value * 0.6;
                    data[idx + 3] = 255;
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        // Get canvas elements
        const canvas2d = document.getElementById('canvas2d');
        const canvas2dAnim = document.getElementById('canvas2d-anim');
        const canvas3d = document.getElementById('canvas3d');
        const canvas3dAnim = document.getElementById('canvas3d-anim');
        const canvasFbm = document.getElementById('canvas-fbm');
        const canvasTurbulence = document.getElementById('canvas-turbulence');

        // Control variables
        let scale2d = 100;
        let scale2dAnim = 80;
        let speed2d = 1.0;
        let zpos = 0;
        let scale3d = 100;
        let scale3dAnim = 80;
        let speed3d = 1.0;
        let octaves = 4;
        let scaleFbm = 100;
        let turbOctaves = 5;
        let scaleTurb = 80;

        // Setup controls
        document.getElementById('scale2d').addEventListener('input', (e) => {
            scale2d = parseFloat(e.target.value);
            document.getElementById('scale2d-val').textContent = scale2d.toFixed(0);
            render2D(canvas2d, scale2d);
        });

        document.getElementById('scale2d-anim').addEventListener('input', (e) => {
            scale2dAnim = parseFloat(e.target.value);
            document.getElementById('scale2d-anim-val').textContent = scale2dAnim.toFixed(0);
        });

        document.getElementById('speed2d').addEventListener('input', (e) => {
            speed2d = parseFloat(e.target.value);
            document.getElementById('speed2d-val').textContent = speed2d.toFixed(1);
        });

        document.getElementById('zpos').addEventListener('input', (e) => {
            zpos = parseFloat(e.target.value);
            document.getElementById('zpos-val').textContent = zpos.toFixed(1);
            render3D(canvas3d, scale3d, zpos);
        });

        document.getElementById('scale3d').addEventListener('input', (e) => {
            scale3d = parseFloat(e.target.value);
            document.getElementById('scale3d-val').textContent = scale3d.toFixed(0);
            render3D(canvas3d, scale3d, zpos);
        });

        document.getElementById('scale3d-anim').addEventListener('input', (e) => {
            scale3dAnim = parseFloat(e.target.value);
            document.getElementById('scale3d-anim-val').textContent = scale3dAnim.toFixed(0);
        });

        document.getElementById('speed3d').addEventListener('input', (e) => {
            speed3d = parseFloat(e.target.value);
            document.getElementById('speed3d-val').textContent = speed3d.toFixed(1);
        });

        document.getElementById('octaves').addEventListener('input', (e) => {
            octaves = parseInt(e.target.value);
            document.getElementById('octaves-val').textContent = octaves;
            renderFBM(canvasFbm, scaleFbm, octaves);
        });

        document.getElementById('scale-fbm').addEventListener('input', (e) => {
            scaleFbm = parseFloat(e.target.value);
            document.getElementById('scale-fbm-val').textContent = scaleFbm.toFixed(0);
            renderFBM(canvasFbm, scaleFbm, octaves);
        });

        document.getElementById('turb-octaves').addEventListener('input', (e) => {
            turbOctaves = parseInt(e.target.value);
            document.getElementById('turb-octaves-val').textContent = turbOctaves;
            renderTurbulence(canvasTurbulence, scaleTurb, turbOctaves);
        });

        document.getElementById('scale-turb').addEventListener('input', (e) => {
            scaleTurb = parseFloat(e.target.value);
            document.getElementById('scale-turb-val').textContent = scaleTurb.toFixed(0);
            renderTurbulence(canvasTurbulence, scaleTurb, turbOctaves);
        });

        // Initial renders
        render2D(canvas2d, scale2d);
        render3D(canvas3d, scale3d, zpos);
        renderFBM(canvasFbm, scaleFbm, octaves);
        renderTurbulence(canvasTurbulence, scaleTurb, turbOctaves);

        // Animation loop
        let time = 0;
        function animate() {
            time += 0.01;
            render2DAnimated(canvas2dAnim, scale2dAnim, time * speed2d);
            render3DAnimated(canvas3dAnim, scale3dAnim, time * speed3d);
            requestAnimationFrame(animate);
        }
        animate();
    </script>
</body>
</html>